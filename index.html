<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CX Trade - Live Market</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        @font-face { font-family: 'BDO Grotesk'; src: url('./fonts/BDOGrotesk-Regular.ttf') format('truetype'); font-weight: 400; font-display: swap; }
        @font-face { font-family: 'BDO Grotesk'; src: url('./fonts/BDOGrotesk-Medium.ttf') format('truetype'); font-weight: 500; font-display: swap; }
        @font-face { font-family: 'BDO Grotesk'; src: url('./fonts/BDOGrotesk-Bold.ttf') format('truetype'); font-weight: 700; font-display: swap; }

        * { font-family: 'BDO Grotesk', sans-serif !important; }
        body { margin: 0; background-color: #050505; color: white; font-family: 'BDO Grotesk', sans-serif; overflow: hidden; touch-action: none; }
        @keyframes fade-in { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fade-in 0.3s ease-out forwards; }
        
        .glass-panel { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 30px; }
        .glass-button { background: rgba(255, 255, 255, 0.10); border-radius: 20px; transition: all 0.2s ease; }
        .glass-button:active { transform: scale(0.96); }
        .tab-item { transition: all 0.2s ease; cursor: pointer; border-radius: 16px; }
        .tab-item:hover { background: rgba(255, 255, 255, 0.05); }

        .toggle-switch { position: relative; width: 44px; height: 24px; background: rgba(255,255,255,0.2); border-radius: 12px; cursor: pointer; transition: background 0.3s; }
        .toggle-switch.active { background: #10B981; }
        .toggle-knob { position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.3s; }
        .toggle-switch.active .toggle-knob { transform: translateX(20px); }

        .zoom-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 40px; background: transparent; cursor: pointer; position: absolute; top: -18px; left: 0; z-index: 20; }
        .zoom-slider::-webkit-slider-thumb { -webkit-appearance: none; height: 40px; width: 40px; background: transparent; cursor: pointer; }
        .cursor-wait { cursor: wait; }
    </style>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const ICONS = {
            search: 'https://raw.githubusercontent.com/etalox/cxtrading/main/png/search.png',
            loader: 'https://raw.githubusercontent.com/etalox/cxtrading/main/png/loader.png',
            trendingUp: './svg/up.svg',
            trendingDown: './svg/up.svg',
            wifiOff: 'https://raw.githubusercontent.com/etalox/cxtrading/main/png/wifiOff.png',
            activityWin: './svg/up.svg',
            activityLoss: './svg/up.svg',
            activityNeutral: 'https://raw.githubusercontent.com/etalox/cxtrading/main/png/neutral.png',
        };

        // ACTIVOS REALES DE BINANCE
        const SYMBOLS = ["BTCUSDT", "ETHUSDT", "SOLUSDT"];
        const SYMBOL_NAMES = ["BITCOIN", "ETHEREUM", "SOLANA"];

        const MarketSim = () => {
            const isMobile = window.innerWidth < 768;
            const INITIAL_ZOOM = isMobile ? 160 : 320;
            const isMobileRef = useRef(isMobile);
            
            const [activeTab, setActiveTab] = useState(0); 
            // Inicializamos con datos placeholder, se actualizarán con la API
            const [assetsInfo, setAssetsInfo] = useState([
                { name: "BITCOIN", price: 0, change: 0 },
                { name: "ETHEREUM", price: 0, change: 0 },
                { name: "SOLANA", price: 0, change: 0 }
            ]);
            
            const [balance, setBalance] = useState(() => {
                try {
                    const saved = localStorage.getItem('cx_balance');
                    return saved ? parseFloat(saved) : 100000;
                } catch (e) { return 100000; }
            });
            useEffect(() => { localStorage.setItem('cx_balance', balance); }, [balance]);

            const createEmptyState = (symbol) => ({
                symbol: symbol,
                visualTicks: [], candles: [], longTermTicks: [], 
                currentValue: 0, visualValue: 0, 
                ticksPerCandle: 6, // Ajustado para datos reales
                targetScroll: 0, scrollOffset: 0, 
                currentAnchor: 0.75, tradeDuration: 10000,
                initialized: false,
                visualMinPrice: undefined, visualMaxPrice: undefined,
                lastUpdateTime: 0
            });

            const marketStatesRef = useRef([
                createEmptyState("BTCUSDT"), 
                createEmptyState("ETHUSDT"), 
                createEmptyState("SOLUSDT")
            ]);
            
            const activeTradesRef = useRef([]); 
            const isNotificationVisible = useRef(false);
            const resultLabelsRef = useRef([]);
            const canvasRef = useRef(null); 
            const containerRef = useRef(null);
            
            const [zoom, setZoom] = useState(INITIAL_ZOOM);
            const zoomTargetRef = useRef(INITIAL_ZOOM);
            const zoomCurrentRef = useRef(INITIAL_ZOOM);
            const isUserInteractingRef = useRef(false);
            const preTradeZoomRef = useRef(null);

            const [activeTradesUI, setActiveTradesUI] = useState([]); 
            const [notifications, setNotifications] = useState([]); 
            const [currentPriceUI, setCurrentPriceUI] = useState(0); 
            const [isGenerating, setIsGenerating] = useState(false); 
            const [currentDuration, setCurrentDuration] = useState(10); 
            const [isOnline, setIsOnline] = useState(navigator.onLine); 
            const [autopilot, setAutopilot] = useState(false);

            // --- CONEXIÓN BINANCE ---
            useEffect(() => {
                const fetchInitialPrices = async () => {
                    try {
                        const responses = await Promise.all(SYMBOLS.map(s => fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${s}`)));
                        const data = await Promise.all(responses.map(r => r.json()));
                        
                        data.forEach((d, i) => {
                            const price = parseFloat(d.price);
                            const state = marketStatesRef.current[i];
                            state.currentValue = price;
                            state.visualValue = price;
                            state.initialized = true;
                            
                            // Crear una vela inicial para que no empiece vacío
                            state.candles.push({ open: price, close: price, high: price, low: price, color: '#10b981' });
                            state.targetScroll = 1; state.scrollOffset = 1;
                        });
                        
                        setAssetsInfo(prev => prev.map((a, i) => ({ ...a, price: parseFloat(data[i].price) })));
                        setCurrentPriceUI(parseFloat(data[activeTab].price));
                    } catch (e) {
                        console.error("Error fetching initial prices", e);
                    }
                };

                fetchInitialPrices();

                // WebSocket Stream para los 3 activos
                const streams = SYMBOLS.map(s => `${s.toLowerCase()}@trade`).join('/');
                const ws = new WebSocket(`wss://stream.binance.com:9443/stream?streams=${streams}`);

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    const stream = message.stream;
                    const data = message.data;
                    
                    // Identificar a qué tab pertenece este dato
                    const symbolIndex = SYMBOLS.findIndex(s => s.toLowerCase() + "@trade" === stream);
                    
                    if (symbolIndex !== -1) {
                        const price = parseFloat(data.p);
                        const state = marketStatesRef.current[symbolIndex];
                        
                        // Actualizar estado crudo
                        state.currentValue = price;
                        state.lastUpdateTime = Date.now();
                        
                        // Lógica de velas (versión simplificada para tiempo real)
                        updateRealTimeCandle(symbolIndex, price);
                    }
                };

                return () => ws.close();
            }, []);

            const updateRealTimeCandle = (tabIndex, price) => {
                const state = marketStatesRef.current[tabIndex];
                state.visualTicks.push(price);
                
                // Acumular ticks. En real, esto debería ser por tiempo (1s), pero por simplicidad usamos conteo
                if (state.visualTicks.length >= state.ticksPerCandle) {
                    const lastCandleClose = state.candles.length > 0 ? state.candles[state.candles.length - 1].close : state.visualTicks[0];
                    const close = state.visualTicks[state.visualTicks.length - 1];
                    const high = Math.max(...state.visualTicks, lastCandleClose);
                    const low = Math.min(...state.visualTicks, lastCandleClose);
                    
                    const newCandle = { 
                        open: lastCandleClose, 
                        close, 
                        high, 
                        low, 
                        color: close >= lastCandleClose ? '#10b981' : '#f43f5e' 
                    };
                    
                    state.candles.push(newCandle);
                    state.targetScroll = state.candles.length;
                    state.visualTicks = []; // Reset ticks
                    
                    // Limpieza de memoria
                    if (state.candles.length > 800) {
                        const deleteCount = state.candles.length - 800;
                        state.candles.splice(0, deleteCount);
                        state.scrollOffset -= deleteCount;
                        state.targetScroll -= deleteCount;
                    }
                }
            };

            const addNotification = useCallback((data) => { 
                if (data.type === 'SIGNAL' && isNotificationVisible.current) return; 
                const id = Date.now() + Math.random(); 
                const duration = data.type === 'OFFLINE' ? 0 : 4000; 
                setNotifications(prev => [{ ...data, id }]); 
                if (data.type !== 'OFFLINE') { 
                    setTimeout(() => { setNotifications(prev => prev.filter(n => n.id !== id)); }, duration); 
                } 
            }, []);

            const handleTabChange = (index) => {
                setActiveTab(index);
                const state = marketStatesRef.current[index];
                setCurrentPriceUI(state.visualValue);
            };

            const executeTrade = (type) => { 
                if (!isOnline) return; 
                const maxTrades = autopilot ? 1 : 4;
                if (activeTradesRef.current.length >= maxTrades) return;
                
                const state = marketStatesRef.current[activeTab]; 
                const now = Date.now(); 
                const duration = 10000; // 10 seg fijos para prueba
                const currentPreciseIndex = state.candles.length + (state.visualTicks.length / state.ticksPerCandle); 

                const newTrade = { 
                    id: Date.now() + Math.random(), 
                    type, 
                    entryPrice: state.visualValue, 
                    entryIndex: currentPreciseIndex, 
                    startTime: now, 
                    expiryTime: now + duration, 
                    amount: 50, // Apuesta fija
                    duration: duration, 
                    tabIndex: activeTab 
                }; 
                
                activeTradesRef.current.push(newTrade); 
                setActiveTradesUI([...activeTradesRef.current]); 
                setBalance(prev => prev - 50); 
            };

            // --- MAIN LOOP (DIBUJO) ---
            useEffect(() => {
                let animationId;
                const lastUIUpdateRef = { current: 0 };
                const UI_UPDATE_RATE_MS = 100;

                const loop = () => {
                    animationId = requestAnimationFrame(loop);
                    
                    const now = Date.now();
                    const state = marketStatesRef.current[activeTab]; 
                    
                    // Actualizar UI HTML (Precios)
                    if (now - lastUIUpdateRef.current >= UI_UPDATE_RATE_MS) {
                        setCurrentPriceUI(state.visualValue);
                        setAssetsInfo(prev => prev.map((info, idx) => ({ ...info, price: marketStatesRef.current[idx].currentValue })));
                        lastUIUpdateRef.current = now;
                    }

                    const canvas = canvasRef.current;
                    if (canvas && state.initialized) {
                        const dpr = window.devicePixelRatio || 1;
                        const width = canvas.width / dpr;
                        const height = canvas.height / dpr;
                        const ctx = canvas.getContext('2d');
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                        
                        // FÍSICA SUAVE
                        const SMOOTHING = 0.1; // Más rápido para datos reales
                        state.visualValue += (state.currentValue - state.visualValue) * 0.2;
                        state.scrollOffset += (state.targetScroll - state.scrollOffset) * SMOOTHING;
                        
                        // FONDO
                        ctx.fillStyle = '#050505';
                        ctx.fillRect(0, 0, width, height);
                        
                        // VELA EN FORMACIÓN (LIVE)
                        const lastClose = state.candles.length > 0 ? state.candles[state.candles.length - 1].close : state.visualValue;
                        let allCandles = [...state.candles];
                        // Añadimos la vela actual temporal
                        allCandles.push({ 
                            open: lastClose, 
                            close: state.visualValue, 
                            high: Math.max(state.visualValue, lastClose), 
                            low: Math.min(state.visualValue, lastClose), 
                            color: state.visualValue >= lastClose ? '#10b981' : '#f43f5e', 
                            isForming: true 
                        });
                        
                        // ZOOM
                        zoomCurrentRef.current += (zoomTargetRef.current - zoomCurrentRef.current) * SMOOTHING;
                        const candleWidth = width / zoomCurrentRef.current;
                        
                        // ANCHOR (Centrado horizontal)
                        if (typeof state.currentAnchor === 'undefined') state.currentAnchor = 0.75;
                        const anchorX = width * state.currentAnchor;
                        const getX = (index) => anchorX - (state.scrollOffset - index) * candleWidth;
                        
                        // ESCALA VERTICAL AUTO
                        let minPrice = Infinity, maxPrice = -Infinity;
                        allCandles.forEach((c, i) => { 
                            const x = getX(i); 
                            if (x > -candleWidth && x < width + candleWidth) { 
                                if (c.low < minPrice) minPrice = c.low; 
                                if (c.high > maxPrice) maxPrice = c.high; 
                            } 
                        });
                        
                        // Fallback si no hay velas
                        if (minPrice === Infinity) { minPrice = state.visualValue * 0.999; maxPrice = state.visualValue * 1.001; }
                        
                        if (typeof state.visualMinPrice === 'undefined') { state.visualMinPrice = minPrice; state.visualMaxPrice = maxPrice; }
                        const targetPadding = (maxPrice - minPrice) * 0.2; // Padding del 20%
                        const targetMin = minPrice - targetPadding;
                        const targetMax = maxPrice + targetPadding;
                        
                        state.visualMinPrice += (targetMin - state.visualMinPrice) * 0.05;
                        state.visualMaxPrice += (targetMax - state.visualMaxPrice) * 0.05;
                        
                        const yMin = state.visualMinPrice;
                        const yMax = state.visualMaxPrice;
                        const getY = (price) => height - ((price - yMin) / (yMax - yMin)) * height;
                        const currentY = getY(state.visualValue);

                        // GRID
                        ctx.strokeStyle = '#222'; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(0, currentY); ctx.lineTo(width, currentY); ctx.stroke(); ctx.setLineDash([]);
                        
                        // DIBUJAR VELAS
                        const barWidth = Math.max(1, candleWidth * 0.8);
                        allCandles.forEach((candle, i) => {
                            const x = getX(i);
                            if (x < -candleWidth || x > width + candleWidth) return;
                            const yOpen = getY(candle.open), yClose = getY(candle.close), yHigh = getY(candle.high), yLow = getY(candle.low);
                            
                            ctx.strokeStyle = candle.color;
                            ctx.lineWidth = Math.max(1, candleWidth * 0.1);
                            ctx.beginPath(); ctx.moveTo(x, yHigh); ctx.lineTo(x, yLow); ctx.stroke();
                            
                            const bodyHeight = Math.max(1, Math.abs(yClose - yOpen));
                            ctx.fillStyle = candle.color;
                            ctx.fillRect(x - barWidth/2, Math.min(yOpen, yClose), barWidth, bodyHeight);
                        });

                        // DIBUJAR TRADES ACTIVOS
                        const activeTrades = activeTradesRef.current.filter(t => t.tabIndex === activeTab);
                        activeTrades.forEach(trade => {
                            const yEntry = getY(trade.entryPrice);
                            const xEntry = getX(trade.entryIndex);
                            const remainingSeconds = (trade.expiryTime - Date.now()) / 1000;
                            // Estimamos dónde estará la vela futura
                            const futureIndex = state.candles.length + (remainingSeconds * 10 / state.ticksPerCandle); // Aprox
                            const xExpire = getX(futureIndex);
                            const color = trade.type === 'BUY' ? '#10b981' : '#f43f5e';
                            
                            ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
                            ctx.beginPath(); ctx.moveTo(xEntry, yEntry); ctx.lineTo(width, yEntry); ctx.stroke();
                            
                            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(xEntry, yEntry, 4, 0, Math.PI*2); ctx.fill();
                        });

                        // PROCESAR TRADES EXPIRADOS (LÓGICA PAPER TRADING)
                        const realNow = Date.now();
                        const expiredTrades = activeTradesRef.current.filter(t => realNow >= t.expiryTime);
                        if (expiredTrades.length > 0) {
                            let totalPayout = 0;
                            expiredTrades.forEach(trade => {
                                const tradeState = marketStatesRef.current[trade.tabIndex];
                                const isWin = trade.type === 'BUY' ? tradeState.currentValue > trade.entryPrice : tradeState.currentValue < trade.entryPrice;
                                if (trade.tabIndex === activeTab) {
                                    const currentPreciseIndex = tradeState.candles.length;
                                    resultLabelsRef.current.push({
                                        id: Date.now() + Math.random(), xIndex: currentPreciseIndex,
                                        price: tradeState.currentValue, profit: isWin ? trade.amount * 0.85 : -trade.amount,
                                        timestamp: Date.now(), type: isWin ? 'WIN' : 'LOSS'
                                    });
                                }
                                if (isWin) totalPayout += trade.amount * 1.85;
                            });
                            activeTradesRef.current = activeTradesRef.current.filter(t => realNow < t.expiryTime);
                            setActiveTradesUI([...activeTradesRef.current]);
                            if (totalPayout > 0) setBalance(b => b + totalPayout);
                        }

                        // LABELS DE RESULTADO
                        resultLabelsRef.current = resultLabelsRef.current.filter(l => (Date.now() - l.timestamp) < 2000);
                        resultLabelsRef.current.forEach(label => {
                            const age = Date.now() - label.timestamp;
                            const yPos = getY(label.price) - 30 - (age/2000 * 50);
                            const xPos = getX(label.xIndex);
                            ctx.fillStyle = label.type === 'WIN' ? '#10B981' : '#F43F5E';
                            ctx.globalAlpha = 1 - (age/2000);
                            ctx.beginPath(); ctx.roundRect(xPos - 40, yPos - 15, 80, 30, 10); ctx.fill();
                            ctx.fillStyle = 'black'; ctx.textAlign = 'center'; ctx.fillText(label.profit > 0 ? `+$${label.profit}` : `-$${Math.abs(label.profit)}`, xPos, yPos+5);
                            ctx.globalAlpha = 1;
                        });

                        // PRICE LABEL ACTUAL
                        const labelY = currentY;
                        ctx.fillStyle = '#111'; ctx.fillRect(width - 80, labelY - 10, 80, 20);
                        ctx.fillStyle = '#fff'; ctx.textAlign = 'right'; ctx.font = '12px monospace'; 
                        ctx.fillText(state.visualValue.toFixed(2), width - 10, labelY + 4);
                    }
                };
                
                loop();
                return () => cancelAnimationFrame(animationId);
            }, [zoom, autopilot, activeTab]);

            useEffect(() => {
                const container = containerRef.current;
                if (!container) return;
                const updateSize = (width, height) => {
                    const canvas = canvasRef.current;
                    if (canvas && width > 0) {
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = width * dpr;
                        canvas.height = height * dpr;
                        canvas.style.width = `${width}px`;
                        canvas.style.height = `${height}px`;
                        isMobileRef.current = width < 768;
                    }
                };
                const rect = container.getBoundingClientRect();
                updateSize(rect.width, rect.height);
                const ro = new ResizeObserver(entries => { const {width, height} = entries[0].contentRect; updateSize(width, height); });
                ro.observe(container);
                return () => ro.disconnect();
            }, []);

            const sliderPercentage = ((zoom - 80) / (500 - 80)) * 100;
            const tradesDisabled = !isOnline || autopilot || activeTradesRef.current.length >= 4;

            return (
                <div className="flex flex-col h-screen relative bg-[#050505] text-white font-sans overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-full z-10" ref={containerRef}>
                        <canvas ref={canvasRef} className="w-full h-full cursor-crosshair" />
                    </div>
                    
                    <div className="absolute top-10 left-0 w-full px-6 md:px-10 flex justify-between items-center z-20 pointer-events-none">
                        <div className="flex flex-col justify-center items-start gap-2">
                            <div className="opacity-50 text-[10px] font-normal">BALANCE (DEMO)</div>
                            <div className="text-sm font-normal">${balance.toLocaleString()}</div>
                        </div>

                        <div className="hidden md:flex items-center gap-[10px] pointer-events-auto">
                            {SYMBOL_NAMES.map((name, idx) => (
                                <div key={idx} onClick={() => handleTabChange(idx)} className={`tab-item h-[60px] px-10 flex items-center justify-center gap-[10px] ${activeTab === idx ? 'border border-white' : 'border border-white/40'}`}>
                                    <div className={`text-sm font-normal ${activeTab === idx ? 'text-white' : 'text-white/40'}`}>{name}</div>
                                </div>
                            ))}
                        </div>

                        <div className="flex flex-col justify-center items-end gap-2">
                            <div className="opacity-50 text-[10px] font-normal">PRECIO BINANCE</div>
                            <div className="text-sm font-normal">${currentPriceUI.toLocaleString(undefined, {minimumFractionDigits: 2})}</div>
                        </div>
                    </div>

                    <div className="absolute top-[120px] w-full flex flex-col items-center gap-4 z-30 pointer-events-none px-4">
                        {notifications.map(note => (
                            <div key={note.id} className="glass-panel px-6 h-16 flex items-center justify-center gap-4 animate-fade-in text-white/90">
                                <div className="text-sm font-medium">{note.type === 'OFFLINE' ? 'SIN CONEXIÓN' : 'NOTIFICACIÓN'}</div>
                            </div>
                        ))}
                         {activeTradesUI.map(trade => (
                            <div key={trade.id} className="h-[62px] py-2 pl-2 pr-[22px] bg-white/10 rounded-[20px] backdrop-blur-[10px] flex items-center justify-center gap-[10px] animate-fade-in">
                                <div className={`w-12 h-12 ${trade.type === 'BUY' ? 'bg-[#10B981]' : 'bg-[#F43F5E]'} rounded-[20px] flex items-center justify-center`}>
                                    <img src={trade.type === 'BUY' ? ICONS.trendingUp : ICONS.trendingDown} className="w-5 h-5 brightness-0" style={trade.type === 'SELL' ? {transform: 'scaleY(-1)'} : {}} />
                                </div>
                                <div className="flex flex-col justify-center items-start gap-1.5">
                                    <div className="opacity-80 text-white/50 text-[10px]">{SYMBOL_NAMES[trade.tabIndex]}</div>
                                    <div className="text-white text-sm font-medium">{trade.type === 'BUY' ? 'COMPRANDO' : 'VENDIENDO'}</div>
                                </div>
                                <div className="text-white text-sm font-medium">{(Math.max(0, (trade.expiryTime - Date.now()) / 1000)).toFixed(1)}s</div>
                            </div>
                        ))}
                    </div>

                    <div className="absolute bottom-6 md:bottom-10 left-1/2 transform -translate-x-1/2 z-30 w-[95%] md:w-auto">
                        <div className="glass-panel p-2 flex flex-col md:flex-row items-center gap-4 md:gap-8">
                            
                            <div className="hidden md:flex w-[240px] items-center justify-center opacity-50 text-xs">
                                DATOS EN VIVO DE BINANCE
                            </div>

                            <div className="w-full md:w-[160px] h-4 relative px-2">
                                <div className="w-full h-[2px] bg-[#333] rounded-full absolute top-1/2 transform -translate-y-1/2"></div>
                                <div className="absolute top-1/2 transform -translate-y-1/2 h-3 w-0.5 bg-white pointer-events-none" style={{ left: `${sliderPercentage}%` }} ></div>
                                <input type="range" min="80" max="500" value={zoom} onChange={(e) => { zoomTargetRef.current = Number(e.target.value); setZoom(Number(e.target.value)); }} className="zoom-slider" />
                            </div>

                            <div className="flex gap-2 w-full md:w-auto">
                                <button onClick={() => executeTrade('BUY')} disabled={tradesDisabled} className={`flex-1 md:w-48 h-16 bg-[#10B981] rounded-[20px] flex items-center justify-center gap-3 active:scale-95 hover:bg-[#15c58b] transition-all ${tradesDisabled ? 'opacity-50' : ''}`}>
                                    <div className="text-black text-sm font-medium">SUBE (CALL)</div>
                                </button>
                                <button onClick={() => executeTrade('SELL')} disabled={tradesDisabled} className={`flex-1 md:w-48 h-16 bg-[#F43F5E] rounded-[20px] flex items-center justify-center gap-3 active:scale-95 hover:bg-[#ff5573] transition-all ${tradesDisabled ? 'opacity-50' : ''}`}>
                                    <div className="text-black text-sm font-medium">BAJA (PUT)</div>
                                </button>
                            </div>

                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MarketSim />);
    </script>
</body>
</html>