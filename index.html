<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CX Trade - Modern Trading </title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
    /* --- FUENTES --- */
    @font-face { font-family: 'BDO Grotesk'; src: url('./fonts/BDOGrotesk-Regular.ttf') format('truetype'); font-weight: 400; font-display: swap; }
    @font-face { font-family: 'BDO Grotesk'; src: url('./fonts/BDOGrotesk-Medium.ttf') format('truetype'); font-weight: 500; font-display: swap; }
    @font-face { font-family: 'BDO Grotesk'; src: url('./fonts/BDOGrotesk-Bold.ttf') format('truetype'); font-weight: 700; font-display: swap; }

    /* --- BASE --- */
    * { font-family: 'BDO Grotesk', sans-serif !important; }
    body { margin: 0; background-color: #050505; color: white; overflow: hidden; touch-action: none; }

    /* --- UTILIDADES GLASS --- */
    .glass-panel { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 30px; }
    .glass-button { background: rgba(255, 255, 255, 0.10); border-radius: 20px; transition: all 0.2s ease; }
    .glass-button:active { transform: scale(0.96); }

    .tab-item { transition: all 0.2s ease; cursor: pointer; border-radius: 16px; }
    .tab-item:hover { background: rgba(255, 255, 255, 0.05); }

    /* --- TOGGLE SWITCH (CORREGIDO) --- */
    .toggle-switch { 
        position: relative; 
        width: 44px; 
        height: 24px; 
        background: rgba(255, 255, 255, 0.1); 
        border-radius: 12px; 
        cursor: pointer; 
        transition: background 0.2s ease;
        flex-shrink: 0;
    }
    .toggle-switch.active { background: rgba(16, 185, 129, 0.3); }
    .toggle-knob { 
        position: absolute; 
        top: 2px; 
        left: 2px; 
        width: 20px; 
        height: 20px; 
        background: rgba(255, 255, 255, 0.3); 
        border-radius: 50%; 
        transition: all 0.2s ease;
    }
    .toggle-switch.active .toggle-knob { 
        left: 22px; 
        background: rgba(16, 185, 129, 0.8); 
    }

    /* --- SLIDER ZOOM --- */
    .zoom-slider {
        -webkit-appearance: none;
        width: 100%;
        height: 2px;
        border-radius: 1px;
        background: rgba(255, 255, 255, 0.1);
        outline: none;
    }
    .zoom-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.4);
        cursor: pointer;
    }
    .zoom-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.4);
        cursor: pointer;
        border: none;
    }

    /* --- ANIMACIONES --- */
    @keyframes fade-in { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    .animate-fade-in { animation: fade-in 0.3s ease forwards; }

    /* --- RESPONSIVE --- */
    @media (max-width: 768px) {
        .glass-panel { border-radius: 20px; }
    }

    /* Hack para activar aceleración por hardware */
    canvas { transform: translateZ(0); will-change: transform; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        /* ========== ICONOS (DATA URLS) ========== */
        const ICONS = {
            plus: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M12 4v16m8-8H4'/%3E%3C/svg%3E",
            minus: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M20 12H4'/%3E%3C/svg%3E",
            trendingUp: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 7h8m0 0v8m0-8l-8 8-4-4-6 6'/%3E%3C/svg%3E",
            trendingDown: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 17h8m0 0V9m0 8l-8-8-4 4-6-6'/%3E%3C/svg%3E",
            chevronDown: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/%3E%3C/svg%3E",
            zap: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 10V3L4 14h7v7l9-11h-7z'/%3E%3C/svg%3E",
            activity: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z'/%3E%3C/svg%3E",
            globe: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z'/%3E%3C/svg%3E"
        };

        const assetsInfo = [
            { id: 'BTCUSD', name: 'BTC/USD', color: '#F7931A', initialPrice: 42000 },
            { id: 'ETHUSD', name: 'ETH/USD', color: '#627EEA', initialPrice: 2200 },
            { id: 'SOLUSD', name: 'SOL/USD', color: '#9945FF', initialPrice: 98 },
            { id: 'XRPUSD', name: 'XRP/USD', color: '#00AAE4', initialPrice: 0.52 },
            { id: 'ADAUSD', name: 'ADA/USD', color: '#0033AD', initialPrice: 0.38 },
            { id: 'DOGUSD', name: 'DOG/USD', color: '#C3A634', initialPrice: 0.08 }
        ];

        /* ============================= */
        /*       COMPONENTE PRINCIPAL     */
        /* ============================= */
        const MarketSim = () => {
            const [activeTab, setActiveTab] = useState(0);
            const [zoom, setZoom] = useState(80);
            const [priceData, setPriceData] = useState(assetsInfo.map(a => ({ price: a.initialPrice, history: [] })));
            const [autopilot, setAutopilot] = useState(false);
            const [balance, setBalance] = useState(10000);
            const [totalInvested, setTotalInvested] = useState(0);
            const [durations] = useState([10, 30, 60, 120]);
            const [currentDurationIndex, setCurrentDurationIndex] = useState(0);
            const [notifications, setNotifications] = useState([]);
            const [activeTrades, setActiveTrades] = useState([]);
            const [closedTrades, setClosedTrades] = useState([]);
            const [aiLearnedCount, setAiLearnedCount] = useState(0);
            const [aiConfidence, setAiConfidence] = useState(0.2);
            const [isOnline, setIsOnline] = useState(true);

            // NUEVO: Estados para gestionar operaciones en botones
            const [buttonStates, setButtonStates] = useState({
                buy: { active: false, timeRemaining: 0, expiryTime: null },
                sell: { active: false, timeRemaining: 0, expiryTime: null }
            });
            const [pendingRestores, setPendingRestores] = useState([]); // Para desktop: controlar restauraciones pendientes

            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const pinchStartRef = useRef(null);
            const isUserInteractingRef = useRef(false);
            const zoomTargetRef = useRef(zoom);
            const interactionTimeoutRef = useRef(null);
            const simulationIntervalRef = useRef(null);
            const isNotificationVisible = useRef(false);
            const tradeIdCounterRef = useRef(1);
            const autopilotLoopRef = useRef(null);
            const tradesDisabledRef = useRef(false);
            const [tradesDisabled, setTradesDisabled] = useState(false);

            const currentDuration = durations[currentDurationIndex];
            const isMobile = window.innerWidth < 768;
            const MAX_CONCURRENT_TRADES = isMobile ? 1 : 3;

            // Detectar si es mobile
            const checkMobile = () => window.innerWidth < 768;

            const addNotification = useCallback((data) => {
                // Filtrar notificaciones de operación abierta/cerrada
                if (data.type === 'TRADE_OPENED' || data.type === 'TRADE_CLOSED') {
                    return; // No mostrar estas notificaciones
                }

                if (data.type === 'SIGNAL' && isNotificationVisible.current) return;

                const id = Date.now() + Math.random();
                setNotifications(prev => {
                    if (data.type === 'SIGNAL' && prev.length === 0) return [{ ...data, id }];
                    if (data.type !== 'OFFLINE') {
                        isNotificationVisible.current = true;
                        setTimeout(() => {
                            setNotifications(p => p.filter(n => n.id !== id));
                            isNotificationVisible.current = false;
                        }, 5000);
                    }
                    return [...prev, { ...data, id }];
                });
            }, []);

            useEffect(() => {
                const handleOnline = () => { 
                    setIsOnline(true); 
                    setNotifications(prev => prev.filter(n => n.type !== 'OFFLINE')); 
                };
                const handleOffline = () => { 
                    setIsOnline(false); 
                    addNotification({ type: 'OFFLINE' }); 
                };

                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);

                if (!navigator.onLine) addNotification({ type: 'OFFLINE' });

                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                };
            }, [addNotification]);

            // Actualizar tiempo restante en botones
            useEffect(() => {
                const interval = setInterval(() => {
                    setButtonStates(prev => {
                        const now = Date.now();
                        const newStates = { ...prev };

                        ['buy', 'sell'].forEach(key => {
                            if (newStates[key].active && newStates[key].expiryTime) {
                                const remaining = Math.max(0, (newStates[key].expiryTime - now) / 1000);
                                newStates[key].timeRemaining = remaining;

                                // En mobile, resetear botón cuando termina la operación
                                if (remaining <= 0 && isMobile) {
                                    newStates[key] = { active: false, timeRemaining: 0, expiryTime: null };
                                }
                            }
                        });

                        return newStates;
                    });
                }, 100);

                return () => clearInterval(interval);
            }, [isMobile]);

            // Desktop: Manejar restauraciones pendientes
            useEffect(() => {
                if (!isMobile && pendingRestores.length > 0) {
                    const now = Date.now();
                    const toRestore = pendingRestores.filter(restore => now >= restore.restoreTime);

                    if (toRestore.length > 0) {
                        toRestore.forEach(restore => {
                            setButtonStates(prev => ({
                                ...prev,
                                [restore.type]: { active: false, timeRemaining: 0, expiryTime: null }
                            }));
                        });

                        setPendingRestores(prev => prev.filter(restore => now < restore.restoreTime));

                        // Habilitar botones si ya no hay operaciones activas
                        const anyActive = Object.values(buttonStates).some(state => state.active);
                        if (!anyActive) {
                            setTradesDisabled(false);
                            tradesDisabledRef.current = false;
                        }
                    }
                }
            }, [pendingRestores, buttonStates, isMobile]);

            const executeTrade = useCallback((type) => {
                if (tradesDisabledRef.current) return;

                const activeCount = activeTrades.filter(t => t.tabIndex === activeTab).length;

                // Verificar límite de operaciones concurrentes
                if (activeCount >= MAX_CONCURRENT_TRADES) return;

                const currentPrice = priceData[activeTab].price;
                const tradeId = tradeIdCounterRef.current++;
                const expiryTime = Date.now() + (currentDuration * 1000);

                const newTrade = {
                    id: tradeId,
                    type,
                    entryPrice: currentPrice,
                    expiryTime,
                    tabIndex: activeTab,
                    duration: currentDuration
                };

                setActiveTrades(prev => [...prev, newTrade]);

                // Actualizar estado del botón
                const buttonKey = type === 'BUY' ? 'buy' : 'sell';
                setButtonStates(prev => ({
                    ...prev,
                    [buttonKey]: { active: true, timeRemaining: currentDuration, expiryTime }
                }));

                // Desktop: Programar restauración después de 5 segundos
                if (!isMobile) {
                    const restoreTime = Date.now() + 5000;
                    setPendingRestores(prev => [...prev, { type: buttonKey, restoreTime }]);

                    // Deshabilitar botones durante 5 segundos
                    setTradesDisabled(true);
                    tradesDisabledRef.current = true;

                    setTimeout(() => {
                        const stillActive = activeTrades.filter(t => t.expiryTime > Date.now()).length;
                        if (stillActive < MAX_CONCURRENT_TRADES) {
                            setTradesDisabled(false);
                            tradesDisabledRef.current = false;
                        }
                    }, 5000);
                }

                // Mobile: Deshabilitar botones hasta que termine la operación
                if (isMobile) {
                    setTradesDisabled(true);
                    tradesDisabledRef.current = true;
                }

                setTimeout(() => {
                    const exitPrice = priceData[activeTab].price;
                    const priceDiff = exitPrice - currentPrice;
                    const isWin = (type === 'BUY' && priceDiff > 0) || (type === 'SELL' && priceDiff < 0);
                    const pnl = isWin ? 100 : -100;

                    setBalance(prev => prev + pnl);
                    setActiveTrades(prev => prev.filter(t => t.id !== tradeId));
                    setClosedTrades(prev => [...prev, { ...newTrade, exitPrice, pnl, isWin }]);

                    setAiLearnedCount(c => c + 1);
                    if (isWin) setAiConfidence(c => Math.min(1, c + 0.02));
                    else setAiConfidence(c => Math.max(0, c - 0.01));

                    // Mobile: Restaurar botón y habilitar
                    if (isMobile) {
                        setButtonStates(prev => ({
                            ...prev,
                            [buttonKey]: { active: false, timeRemaining: 0, expiryTime: null }
                        }));
                        setTradesDisabled(false);
                        tradesDisabledRef.current = false;
                    }
                }, currentDuration * 1000);

            }, [activeTab, priceData, currentDuration, activeTrades, MAX_CONCURRENT_TRADES, isMobile]);

            const handleNotificationClick = (notification) => {
                if (notification.type === 'SIGNAL') {
                    executeTrade(notification.signalType);
                }
            };

            useEffect(() => {
                const generateSignal = () => {
                    if (autopilot && !isNotificationVisible.current && isOnline) {
                        const signalType = Math.random() > 0.5 ? 'BUY' : 'SELL';
                        const confidence = 0.6 + Math.random() * 0.3;
                        const newPrice = priceData[activeTab].price;
                        addNotification({
                            type: 'SIGNAL',
                            signalType: signalType,
                            confidence: confidence,
                            price: newPrice
                        });
                    }
                };

                if (autopilot) {
                    autopilotLoopRef.current = setInterval(generateSignal, 8000);
                } else {
                    if (autopilotLoopRef.current) {
                        clearInterval(autopilotLoopRef.current);
                        autopilotLoopRef.current = null;
                    }
                    setNotifications(prev => prev.filter(n => n.type !== 'SIGNAL'));
                    isNotificationVisible.current = false;
                }

                return () => {
                    if (autopilotLoopRef.current) {
                        clearInterval(autopilotLoopRef.current);
                        autopilotLoopRef.current = null;
                    }
                };
            }, [autopilot, priceData, activeTab, addNotification, isOnline]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d', { 
                    alpha: false, 
                    desynchronized: true 
                });

                const resizeCanvas = () => {
                    canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                    canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                };

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                return () => window.removeEventListener('resize', resizeCanvas);
            }, []);

            useEffect(() => {
                const updatePrices = () => {
                    setPriceData(prev => prev.map((data, idx) => {
                        const volatility = assetsInfo[idx].initialPrice * 0.0002;
                        const change = (Math.random() - 0.5) * volatility * 2;
                        const newPrice = data.price + change;
                        const newHistory = [...data.history, newPrice].slice(-1000);
                        return { price: newPrice, history: newHistory };
                    }));
                };

                updatePrices();
                simulationIntervalRef.current = setInterval(updatePrices, 100);

                return () => {
                    if (simulationIntervalRef.current) clearInterval(simulationIntervalRef.current);
                };
            }, []);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;

                const draw = () => {
                    ctx.fillStyle = '#050505';
                    ctx.fillRect(0, 0, width, height);

                    const history = priceData[activeTab].history;
                    if (history.length < 2) return;

                    const visiblePoints = Math.floor(zoom * 2);
                    const dataSlice = history.slice(-visiblePoints);

                    const minPrice = Math.min(...dataSlice);
                    const maxPrice = Math.max(...dataSlice);
                    const priceRange = maxPrice - minPrice || 1;

                    const padding = height * 0.1;
                    const chartHeight = height - 2 * padding;

                    const xStep = width / (dataSlice.length - 1);

                    ctx.strokeStyle = assetsInfo[activeTab].color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    dataSlice.forEach((price, i) => {
                        const x = i * xStep;
                        const y = padding + chartHeight * (1 - (price - minPrice) / priceRange);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });

                    ctx.stroke();

                    const currentPrice = dataSlice[dataSlice.length - 1];
                    const currentY = padding + chartHeight * (1 - (currentPrice - minPrice) / priceRange);

                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, currentY);
                    ctx.lineTo(width, currentY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.fillStyle = assetsInfo[activeTab].color;
                    ctx.beginPath();
                    ctx.arc(width - 5, currentY, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px BDO Grotesk';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.textAlign = 'right';
                    ctx.fillText(currentPrice.toFixed(2), width - 15, currentY - 10);
                };

                draw();
            }, [priceData, activeTab, zoom]);

            useEffect(() => {
                if (interactionTimeoutRef.current) clearTimeout(interactionTimeoutRef.current);

                interactionTimeoutRef.current = setTimeout(() => {
                    isUserInteractingRef.current = false;
                }, 500);

                return () => {
                    if (interactionTimeoutRef.current) clearTimeout(interactionTimeoutRef.current);
                };
            }, [zoom]);

            const handleWheel = useCallback((e) => {
                e.preventDefault();
                isUserInteractingRef.current = true;

                const delta = -e.deltaY * 0.2;
                const newZoom = Math.max(20, Math.min(500, zoom + delta));

                zoomTargetRef.current = newZoom;
                setZoom(newZoom);
            }, [zoom]);

            useEffect(() => {
                const container = containerRef.current;
                if (!container) return;

                container.addEventListener('wheel', handleWheel, { passive: false });

                return () => container.removeEventListener('wheel', handleWheel);
            }, [handleWheel]);

            useEffect(() => {
                const handleTouchStart = (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                        pinchStartRef.current = { distance: dist, zoom };
                        isUserInteractingRef.current = true;
                    }
                };

                const handleTouchMove = (e) => {
                    if (e.touches.length === 2 && pinchStartRef.current) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const dist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                        const scale = dist / pinchStartRef.current.distance;
                        const newZoom = Math.max(20, Math.min(500, pinchStartRef.current.zoom * scale));
                        zoomTargetRef.current = newZoom;
                        setZoom(newZoom);
                    }
                };

                const handleTouchEnd = (e) => {
                    if (e.touches.length < 2) {
                        pinchStartRef.current = null;
                    }
                };

                const container = containerRef.current;
                if (container) {
                    container.addEventListener('touchstart', handleTouchStart, { passive: false });
                    container.addEventListener('touchmove', handleTouchMove, { passive: false });
                    container.addEventListener('touchend', handleTouchEnd);
                }

                return () => {
                    if (container) {
                        container.removeEventListener('touchstart', handleTouchStart);
                        container.removeEventListener('touchmove', handleTouchMove);
                        container.removeEventListener('touchend', handleTouchEnd);
                    }
                };
            }, [zoom, addNotification, activeTab, autopilot]);

            const activeTradesUI = activeTrades.filter(t => t.tabIndex === activeTab);
            const totalPnL = balance + totalInvested - 10000;
            const pnlClass = totalPnL >= 0 ? 'text-[#10B981]' : 'text-[#F43F5E]';
            const pnlSign = totalPnL >= 0 ? '+' : '';

            return (
                <div className="relative w-screen h-screen">
                    <div ref={containerRef} className="absolute inset-0 bg-[#050505]">
                        <canvas ref={canvasRef} className="w-full h-full" />
                    </div>

                    <div className="absolute top-4 md:top-6 left-6 md:left-10 right-6 md:right-10 z-20 flex flex-col md:flex-row justify-between items-start md:items-center gap-4 md:gap-0 pointer-events-auto">
                        <div className="flex items-center gap-3">
                            <div className="glass-panel px-4 py-2 flex items-center gap-3">
                                <div className="text-white/40 text-xs font-normal">SALDO</div>
                                <div className="text-white text-lg font-bold">${balance.toFixed(2)}</div>
                                <div className={`${pnlClass} text-xs font-medium`}>{pnlSign}${totalPnL.toFixed(2)}</div>
                            </div>
                        </div>

                        <div className="flex items-center gap-2">
                            <div className="glass-panel px-3 py-2 flex items-center gap-2 md:gap-3 text-xs md:text-sm">
                                <img src={ICONS.zap} className="w-4 h-4 text-white" style={{ filter: 'invert(1)' }} />
                                <span className="text-white/60 font-normal hidden md:inline">Autopilot</span>
                                <div 
                                    className={`toggle-switch ${autopilot ? 'active' : ''}`}
                                    onClick={() => setAutopilot(!autopilot)}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="absolute top-20 md:top-24 left-1/2 transform -translate-x-1/2 z-20 flex flex-col gap-2 max-w-md w-full px-4 pointer-events-auto">
                        {notifications.filter(n => n.type !== 'TRADE_OPENED' && n.type !== 'TRADE_CLOSED').map(note => {
                            const isBuy = note.signalType === 'BUY';
                            const bgColor = note.type === 'OFFLINE' ? 'bg-white/5' : (isBuy ? 'bg-[#10B981]' : 'bg-[#F43F5E]');
                            const shadowClass = note.type === 'OFFLINE' ? '' : (isBuy ? 'shadow-[0_0_20px_rgba(16,185,129,0.20)]' : 'shadow-[0_0_20px_rgba(244,63,94,0.20)]');
                            const icon = note.type === 'OFFLINE' ? ICONS.globe : (isBuy ? ICONS.trendingUp : ICONS.trendingDown);
                            const iconStyle = (note.type !== 'OFFLINE' && !isBuy) ? { transform: 'scaleY(-1)' } : {};

                            return (
                                <div 
                                    key={note.id} 
                                    className={`h-[62px] py-2 pl-2 pr-[22px] ${note.type === 'OFFLINE' ? 'bg-white/10' : bgColor} ${shadowClass} rounded-[20px] backdrop-blur-[10px] flex items-center justify-center gap-[10px] cursor-pointer active:scale-95 transition-transform animate-fade-in`}
                                    onClick={() => handleNotificationClick(note)}
                                >
                                    <div className={`w-12 h-12 ${note.type === 'OFFLINE' ? 'bg-white/10' : 'bg-black/20'} rounded-[15px] flex items-center justify-center shrink-0`}>
                                        <img src={icon} className="w-5 h-5 brightness-0 invert" style={iconStyle} />
                                    </div>
                                    <div className="flex flex-col justify-center items-start gap-0 flex-1">
                                        <div className="opacity-80 text-white/50 text-[10px] font-normal capitalize">
                                            {note.type === 'SIGNAL' ? `${note.signalType} SIGNAL` : 'NOTIFICACIÓN'}
                                        </div>
                                        <div className="text-sm font-medium">
                                            {note.type === 'SIGNAL' ? `CONF: ${(note.confidence*100).toFixed(0)}%` : 'SISTEMA'}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}

                        {activeTradesUI.map(trade => {
                            const tradeAsset = assetsInfo[trade.tabIndex].name;
                            const isBuy = trade.type === 'BUY';
                            const bgColor = isBuy ? 'bg-[#10B981]' : 'bg-[#F43F5E]';
                            const shadowClass = isBuy ? 'shadow-[0_0_20px_rgba(16,185,129,0.20)]' : 'shadow-[0_0_20px_rgba(244,63,94,0.20)]';
                            const icon = isBuy ? ICONS.trendingUp : ICONS.trendingDown;
                            const iconStyle = isBuy ? {} : { transform: 'scaleY(-1)' };

                            return (
                                <div key={trade.id} className="h-[62px] py-2 pl-2 pr-[22px] bg-white/10 rounded-[20px] backdrop-blur-[10px] flex items-center justify-center gap-[10px] animate-fade-in">
                                    <div className={`w-12 h-12 ${bgColor} ${shadowClass} rounded-[15px] flex items-center justify-center shrink-0`}>
                                        <img src={icon} className="w-5 h-5 brightness-0" style={iconStyle} />
                                    </div>

                                    <div className="flex flex-col justify-center items-start gap-1.5 flex-1">
                                        <div className="opacity-80 text-white/50 text-[10px] font-normal font-sans leading-none">
                                            {isMobile ? 'OPERACIÓN ABIERTA' : tradeAsset}
                                        </div>

                                        <div className="flex items-baseline justify-start w-full gap-4">
                                            <div className="text-white text-sm font-medium font-sans leading-none uppercase">
                                                {isBuy ? 'COMPRANDO...' : 'VENDIENDO...'}
                                            </div>
                                            <div className="text-white text-sm font-medium font-sans leading-none tabular-nums">
                                                {(Math.max(0, (trade.expiryTime - Date.now()) / 1000)).toFixed(1)}s
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    <div className="absolute top-28 left-6 md:left-10 z-10 flex flex-col gap-1 pointer-events-none opacity-40">
                         <div className="text-[10px] font-bold text-[#444] tracking-widest">ADAPTIVE CRITIC</div>
                         <div className="flex items-center gap-2">
                            <div className="w-10 h-1 bg-[#222] rounded-full overflow-hidden">
                                <div className="h-full bg-white/40" style={{ width: `${aiConfidence * 100}%` }}></div>
                            </div>
                            <span className="text-[9px] text-[#555]">{aiLearnedCount} OPS</span>
                         </div>
                    </div>

                    <div className="absolute bottom-8 md:bottom-10 left-1/2 transform -translate-x-1/2 z-30 w-[95%] md:w-auto">
                        <div className="glass-panel p-4 md:p-6">
                            <div className="flex items-center gap-2 md:gap-4 mb-3 md:mb-4 overflow-x-auto scrollbar-hide">
                                {assetsInfo.map((asset, idx) => (
                                    <div
                                        key={asset.id}
                                        onClick={() => setActiveTab(idx)}
                                        className={`tab-item px-3 py-2 flex items-center gap-2 cursor-pointer transition-all shrink-0 ${
                                            activeTab === idx ? 'bg-white/10' : ''
                                        }`}
                                    >
                                        <div className="w-2 h-2 rounded-full" style={{ backgroundColor: asset.color }}></div>
                                        <span className="text-white text-xs md:text-sm font-medium">{asset.name}</span>
                                        <span className="text-white/40 text-xs">${priceData[idx].price.toFixed(2)}</span>
                                    </div>
                                ))}
                            </div>

                            <div className="flex flex-col md:flex-row items-center gap-3 md:gap-4">
                                <div className="flex items-center gap-2 px-3 py-2 glass-button order-1 md:order-1">
                                    <img src={ICONS.activity} className="w-4 h-4" style={{ filter: 'invert(1) opacity(0.6)' }} />
                                    <div className="flex items-center gap-2">
                                        {durations.map((dur, idx) => (
                                            <div
                                                key={dur}
                                                onClick={() => setCurrentDurationIndex(idx)}
                                                className={`px-2 py-1 rounded-lg text-xs cursor-pointer transition-all ${
                                                    currentDurationIndex === idx ? 'bg-white/20 text-white' : 'text-white/40'
                                                }`}
                                            >
                                                {dur}s
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <div className="flex items-center gap-2 px-3 py-2 glass-button w-full md:w-auto order-3 md:order-2">
                                    <img src={ICONS.minus} className="w-4 h-4" style={{ filter: 'invert(1) opacity(0.4)' }} />
                                    <input 
                                        type="range" 
                                        min="20" 
                                        max="500" 
                                        value={580 - zoom}
                                        onChange={(e) => { 
                                            const val = Number(e.target.value); 
                                            const invertedVal = 580 - val;
                                            isUserInteractingRef.current = true; 
                                            zoomTargetRef.current = invertedVal; 
                                            setZoom(invertedVal); 
                                        }} 
                                        className="zoom-slider" 
                                    />
                                    <img src={ICONS.plus} className="w-4 h-4" style={{ filter: 'invert(1) opacity(0.4)' }} />
                                </div>

                                <div className="flex gap-2 w-full md:w-auto order-2 md:order-5">
                                    <button 
                                        onClick={() => executeTrade('BUY')} 
                                        disabled={tradesDisabled || (buttonStates.buy.active && !isMobile)}
                                        className={`flex-1 md:w-48 h-16 bg-[#10B981] rounded-[20px] shadow-[0_0_20px_rgba(16,185,129,0.2)] flex items-center justify-center gap-3 active:scale-95 hover:bg-[#15c58b] transition-all ${(tradesDisabled || (buttonStates.buy.active && !isMobile)) ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    >
                                        <img src={ICONS.trendingUp} className="w-5 h-5" style={{ filter: 'brightness(0)' }} />
                                        <div className="flex flex-col items-start gap-0 text-black">
                                            <div className="opacity-60 text-[10px] font-normal">
                                                {buttonStates.buy.active ? 'OPERACIÓN ABIERTA' : 'OPERAR COMPRA'}
                                            </div>
                                            <div className="text-sm font-medium flex items-baseline gap-2">
                                                <span>{buttonStates.buy.active ? 'COMPRANDO...' : `BUY / ${currentDuration}s.`}</span>
                                                {buttonStates.buy.active && (
                                                    <span className="tabular-nums">{buttonStates.buy.timeRemaining.toFixed(1)}s</span>
                                                )}
                                            </div>
                                        </div>
                                    </button>

                                    <button 
                                        onClick={() => executeTrade('SELL')} 
                                        disabled={tradesDisabled || (buttonStates.sell.active && !isMobile)}
                                        className={`flex-1 md:w-48 h-16 bg-[#F43F5E] rounded-[20px] shadow-[0_0_20px_rgba(244,63,94,0.2)] flex items-center justify-center gap-3 active:scale-95 hover:bg-[#ff5573] transition-all ${(tradesDisabled || (buttonStates.sell.active && !isMobile)) ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    >
                                        <img src={ICONS.trendingDown} className="w-5 h-5" style={{ filter: 'brightness(0)', transform: 'scaleY(-1)' }} />
                                        <div className="flex flex-col items-start gap-0 text-black">
                                            <div className="opacity-60 text-[10px] font-normal">
                                                {buttonStates.sell.active ? 'OPERACIÓN ABIERTA' : 'OPERAR VENTA'}
                                            </div>
                                            <div className="text-sm font-medium flex items-baseline gap-2">
                                                <span>{buttonStates.sell.active ? 'VENDIENDO...' : `SELL / ${currentDuration}s.`}</span>
                                                {buttonStates.sell.active && (
                                                    <span className="tabular-nums">{buttonStates.sell.timeRemaining.toFixed(1)}s</span>
                                                )}
                                            </div>
                                        </div>
                                    </button>
                                </div>

                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MarketSim />);
    </script>
</body>
</html>